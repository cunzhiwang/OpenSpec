# CLI 归档命令规范

## 目的
归档命令将已完成的变更从活动变更目录移动到带有日期前缀命名的归档文件夹，遵循 OpenSpec 约定。

## 命令语法
```bash
openspec archive [change-name] [--yes|-y]
```

选项：
- `--yes`、`-y`：跳过确认提示（用于自动化）

## 需求
### 需求：变更选择

命令应当支持交互式和直接变更选择两种方法。

#### 场景：交互式选择

- **当** 未提供 change-name 时
- **则** 显示可用变更的交互式列表（排除 archive/）
- **并且** 允许用户选择一个

#### 场景：直接选择

- **当** 提供 change-name 时
- **则** 直接使用该变更
- **并且** 验证其存在

### 需求：任务完成检查

命令应当在归档前验证任务完成状态，以防止过早归档。

#### 场景：发现未完成任务

- **当** 发现未完成任务（标记为 `- [ ]`）时
- **则** 向用户显示所有未完成任务
- **并且** 提示确认是否继续
- **并且** 为安全起见默认为"否"

#### 场景：所有任务完成

- **当** 所有任务完成或不存在 tasks.md 时
- **则** 无需提示即可继续归档

### 需求：归档过程

归档操作应当遵循结构化过程，安全地将变更移动到归档。

#### 场景：执行归档

- **当** 归档变更时
- **则** 执行以下步骤：
  1. 如果不存在则创建 archive/ 目录
  2. 使用当前日期生成目标名称 `YYYY-MM-DD-[change-name]`
  3. 检查目标目录是否已存在
  4. 从变更的未来状态规范更新主规范（见下方规范更新过程）
  5. 将整个变更目录移动到归档位置

#### 场景：归档已存在

- **当** 目标归档已存在时
- **则** 显示错误消息失败
- **并且** 不覆盖现有归档

#### 场景：成功归档

- **当** 移动成功时
- **则** 显示成功消息，包含归档名称和已更新规范列表

### 需求：规范更新过程

在将变更移动到归档之前，命令应当将增量变更应用到主规范，以反映部署的现实。

#### 场景：应用增量变更

- **当** 归档包含基于增量的规范的变更时
- **则** 按照 openspec-conventions 中的定义解析和应用增量变更
- **并且** 在应用前验证所有操作

#### 场景：验证增量变更

- **当** 处理增量变更时
- **则** 按照 openspec-conventions 中的规定执行验证
- **并且** 如果验证失败，显示具体错误并中止

#### 场景：冲突检测

- **当** 应用增量会创建重复的需求标题时
- **则** 中止并显示冲突的错误消息
- **并且** 建议手动解决

### 需求：确认行为

规范更新确认应当在应用变更前提供清晰的可见性。

#### 场景：显示确认

- **当** 提示确认时
- **则** 显示清晰的摘要，包括：
  - 将创建哪些规范（新能力）
  - 将更新哪些规范（现有能力）
  - 每个规范的源路径
- **并且** 格式化确认提示如下：
  ```
  将更新以下规范：
  
  要创建的新规范：
    - cli-archive（来自 changes/add-archive-command/specs/cli-archive/spec.md）
  
  要更新的现有规范：
    - cli-init（来自 changes/update-init-command/specs/cli-init/spec.md）
  
  更新 2 个规范并归档 'add-archive-command'？[y/N]：
  ```

#### 场景：处理确认响应

- **当** 等待用户确认时
- **则** 为安全起见默认为"否"（需要明确的 "y" 或 "yes"）
- **并且** 提供 `--yes` 或 `-y` 标志时跳过确认

#### 场景：用户拒绝确认

- **当** 用户拒绝确认时
- **则** 中止整个归档操作
- **并且** 显示消息："归档已取消。未做任何更改。"
- **并且** 以非零状态码退出

### 需求：错误条件

命令应当优雅地处理各种错误条件。

#### 场景：处理错误

- **当** 发生错误时
- **则** 处理以下条件：
  - 缺少 openspec/changes/ 目录
  - 未找到变更
  - 归档目标已存在
  - 文件系统权限问题

### 需求：跳过规范选项

归档命令应当支持 `--skip-specs` 标志，跳过所有规范更新操作，直接进行归档。

#### 场景：使用标志跳过规范更新

- **当** 执行 `openspec archive <change> --skip-specs` 时
- **则** 跳过规范发现和更新确认
- **并且** 直接将变更移动到归档
- **并且** 显示消息表明已跳过规范

### 需求：非阻塞确认

当用户拒绝规范更新时，归档操作应当继续进行，而不是取消整个操作。

#### 场景：用户拒绝规范更新确认

- **当** 用户拒绝规范更新确认时
- **则** 跳过规范更新
- **并且** 继续归档操作
- **并且** 显示成功消息，表明规范未更新

### 需求：显示输出

命令应当提供关于增量操作的清晰反馈。

#### 场景：显示增量应用

- **当** 应用增量变更时
- **则** 为每个规范显示：
  - 添加的需求数量
  - 修改的需求数量
  - 删除的需求数量
  - 重命名的需求数量
- **并且** 按照 openspec-conventions 定义使用标准输出符号（+ ~ - →）：
  ```
  正在应用变更到 specs/user-auth/spec.md：
    + 2 个已添加
    ~ 3 个已修改
    - 1 个已删除
    → 1 个已重命名
  ```

### 需求：归档验证

归档命令应当在应用变更前验证变更，以确保数据完整性。

#### 场景：归档前验证

- **当** 执行 `openspec archive change-name` 时
- **则** 首先验证变更结构
- **并且** 仅在验证通过时继续
- **并且** 验证失败时显示验证错误

#### 场景：强制归档而不验证

- **当** 执行 `openspec archive change-name --no-validate` 时
- **则** 跳过验证（不安全模式）
- **并且** 显示关于跳过验证的警告

## 决策原因

**交互式选择**：减少输入，帮助用户查看可用变更
**任务检查**：防止意外归档未完成的工作
**日期前缀**：维护时间顺序，防止命名冲突
**禁止覆盖**：保留历史归档，防止数据丢失
**归档前更新规范**：主目录中的规范代表当前现实；当变更部署并归档时，其未来状态规范成为新的现实，必须替换主规范
**规范更新确认**：提供将发生变更的可见性，防止意外覆盖，确保用户在修改规范前了解影响
**自动化的 --yes 标志**：允许 CI/CD 管道无需交互式提示即可归档，同时默认为手动使用保持安全
