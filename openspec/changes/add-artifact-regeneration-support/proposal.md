# 添加产物重新生成支持

## 问题

目前，在 OPSX 工作流中**没有办法重新生成产物**：

- `/opsx:apply` 只是读取磁盘上的内容
- `/opsx:continue` 只创建下一个产物 - 不会触及现有产物

如果你在 `tasks.md` 存在后编辑了 `design.md`，你唯一的选择是：
1. 手动删除 tasks.md，然后运行 `/opsx:continue`
2. 手动编辑 tasks.md

文档声称你可以"在中途更新产物并继续"，但实际上没有机制支持这一点。

## 提议的解决方案

两部分：

### 第一部分：过期检测

向 `/opsx:apply` 添加产物过期检测：

1. **跟踪修改时间**：生成产物时，记录其依赖项的 mtime
2. **检测过期**：当 `/opsx:apply` 运行时，检查上游产物（design.md、specs）是否在 tasks.md 生成后被修改
3. **提示用户**：如果过期，询问："设计在任务生成后被修改。您是否要使用 `/opsx:continue` 重新生成任务？"

## 用户体验

### 愿景：无缝中途修正

这是我们想要启用的工作流（目前有文档但不支持）：

```
你: /opsx:apply

AI:  处理任务中...
     ✓ 任务 1.1：创建了缓存层
     ✓ 任务 1.2：添加了缓存失效

     正在处理 1.3：实现 TTL...
     我注意到设计假设使用 Redis，但你的项目使用
     内存缓存。我应该更新设计吗？

你: 是的，更新它以使用现有的缓存模块。

AI:  更新了 design.md 以使用 src/cache/ 中的 CacheManager
     使用修订后的实现步骤更新了 tasks.md
     继续实现...
     ✓ 任务 1.3：使用 CacheManager 实现了 TTL
     ...
```

**无需重启。** 只需更新产物并继续。

### 过期警告用户体验

当用户手动编辑上游产物时：

```
$ /opsx:apply

⚠️  检测到上游产物的更改：
    - design.md 在 5 分钟前被修改（在 tasks.md 生成之后）

选项：
1. 重新生成任务（推荐）
2. 无论如何继续使用当前任务
3. 取消

>
```

### 第二部分：重新生成能力

添加重新生成特定产物的方法：

```bash
# 选项 A：continue 上的标志
/opsx:continue --regenerate tasks

# 选项 B：单独的命令
/opsx:regenerate tasks

# 选项 C：检测到过期时的交互式提示
/opsx:apply
# "设计已更改。重新生成任务？[y/N]"
```

## 技术方案

### 选项 A：元数据文件

在变更目录中存储 `.openspec-meta.json`：
```json
{
  "tasks.md": {
    "generated_at": "2025-01-24T10:00:00Z",
    "dependencies": {
      "design.md": "2025-01-24T09:55:00Z",
      "specs/feature/spec.md": "2025-01-24T09:50:00Z"
    }
  }
}
```

### 选项 B：前置元数据

向生成的产物添加 YAML 前置元数据：
```markdown
---
generated_at: 2025-01-24T10:00:00Z
depends_on:
  - design.md@2025-01-24T09:55:00Z
---
# 任务
...
```

### 选项 C：基于 Git

使用 git 检测上游文件是否在下游最后修改后发生了变化。不需要额外的元数据，但需要 git。

## 非目标

- 自动重新生成（用户应始终选择）
- 完全阻止应用（只是警告）
- 跟踪代码文件更改（只跟踪产物依赖）

## 依赖项

- 应在 `fix-midflight-update-docs` 之后实施，以便文档首先是准确的
- 如果需要，可以与该变更合并

## 成功标准

- 当使用过期产物应用时用户会收到警告
- 如果需要，有明确的重新生成路径
- 没有误报（只在真正过期时警告）
- 文档声称变为实际可用
